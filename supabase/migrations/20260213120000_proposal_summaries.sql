-- Proposal summaries generated by LLM and keyed by proposal status

do $$
begin
  if not exists (
    select 1
    from pg_type
    where typname = 'proposal_summary_generation_status'
  ) then
    create type proposal_summary_generation_status as enum ('pending', 'ready', 'failed');
  end if;
end $$;

create table if not exists public.proposal_summaries (
  id uuid primary key default gen_random_uuid(),
  proposal_id uuid not null references public.law_proposals(id) on delete cascade,
  proposal_status law_proposal_status not null,
  generation_status proposal_summary_generation_status not null default 'pending',
  summary_payload jsonb,
  model_id text,
  prompt_version text not null default 'proposal_summary_v1',
  source_url text,
  source_method text,
  attempt_count integer not null default 0,
  last_attempt_at timestamptz,
  generated_at timestamptz,
  next_retry_at timestamptz,
  last_error_code text,
  last_error_message_safe text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  unique (proposal_id, proposal_status),
  check (attempt_count >= 0)
);

create index if not exists proposal_summaries_lookup_idx
  on public.proposal_summaries (proposal_id, proposal_status, generation_status);

create or replace function public.set_updated_at_timestamp()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

drop trigger if exists proposal_summaries_set_updated_at on public.proposal_summaries;

create trigger proposal_summaries_set_updated_at
before update on public.proposal_summaries
for each row
execute function public.set_updated_at_timestamp();

create or replace function public.claim_proposal_summary_generation(
  p_proposal_id uuid,
  p_proposal_status law_proposal_status,
  p_pending_ttl_seconds integer default 180,
  p_retry_cooldown_seconds integer default 3600,
  p_prompt_version text default 'proposal_summary_v1',
  p_model_id text default 'gpt-4.1-mini'
)
returns table (
  decision text,
  summary_id uuid
)
language plpgsql
security definer
set search_path = public
as $$
declare
  v_now timestamptz := now();
  v_row public.proposal_summaries%rowtype;
  v_pending_ttl_seconds integer := greatest(coalesce(p_pending_ttl_seconds, 180), 1);
  v_retry_cooldown_seconds integer := greatest(coalesce(p_retry_cooldown_seconds, 3600), 1);
begin
  select *
  into v_row
  from public.proposal_summaries
  where proposal_id = p_proposal_id
    and proposal_status = p_proposal_status
  for update;

  if not found then
    insert into public.proposal_summaries (
      proposal_id,
      proposal_status,
      generation_status,
      model_id,
      prompt_version,
      attempt_count,
      last_attempt_at,
      next_retry_at,
      last_error_code,
      last_error_message_safe
    ) values (
      p_proposal_id,
      p_proposal_status,
      'pending',
      p_model_id,
      p_prompt_version,
      1,
      v_now,
      null,
      null,
      null
    )
    returning id into summary_id;

    decision := 'claimed';
    return next;
    return;
  end if;

  summary_id := v_row.id;

  if v_row.generation_status = 'ready' then
    decision := 'already_ready';
    return next;
    return;
  end if;

  if v_row.generation_status = 'pending'
    and v_row.last_attempt_at is not null
    and v_row.last_attempt_at > v_now - make_interval(secs => v_pending_ttl_seconds) then
    decision := 'already_pending';
    return next;
    return;
  end if;

  if v_row.generation_status = 'failed'
    and v_row.next_retry_at is not null
    and v_row.next_retry_at > v_now then
    decision := 'cooldown';
    return next;
    return;
  end if;

  update public.proposal_summaries
  set
    generation_status = 'pending',
    summary_payload = null,
    model_id = p_model_id,
    prompt_version = p_prompt_version,
    source_url = null,
    source_method = null,
    attempt_count = v_row.attempt_count + 1,
    last_attempt_at = v_now,
    generated_at = null,
    next_retry_at = null,
    last_error_code = null,
    last_error_message_safe = null
  where id = v_row.id;

  decision := 'claimed';
  return next;
  return;
end;
$$;
